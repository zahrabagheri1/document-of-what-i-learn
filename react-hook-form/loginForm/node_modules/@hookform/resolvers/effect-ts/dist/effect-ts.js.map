{"version":3,"file":"effect-ts.js","sources":["../src/effect-ts.ts"],"sourcesContent":["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport { Effect } from 'effect';\n\nimport { ArrayFormatter, decodeUnknown } from 'effect/ParseResult';\nimport { type FieldError, appendErrors } from 'react-hook-form';\nimport type { Resolver } from './types';\n\nexport const effectTsResolver: Resolver =\n  (schema, config = { errors: 'all', onExcessProperty: 'ignore' }) =>\n  (values, _, options) => {\n    return decodeUnknown(\n      schema,\n      config,\n    )(values).pipe(\n      Effect.catchAll((parseIssue) =>\n        Effect.flip(ArrayFormatter.formatIssue(parseIssue)),\n      ),\n      Effect.mapError((issues) => {\n        const validateAllFieldCriteria =\n          !options.shouldUseNativeValidation && options.criteriaMode === 'all';\n\n        const errors = issues.reduce(\n          (acc, error) => {\n            const key = error.path.join('.');\n\n            if (!acc[key]) {\n              acc[key] = { message: error.message, type: error._tag };\n            }\n\n            if (validateAllFieldCriteria) {\n              const types = acc[key].types;\n              const messages = types && types[String(error._tag)];\n\n              acc[key] = appendErrors(\n                key,\n                validateAllFieldCriteria,\n                acc,\n                error._tag,\n                messages\n                  ? ([] as string[]).concat(messages as string[], error.message)\n                  : error.message,\n              ) as FieldError;\n            }\n\n            return acc;\n          },\n          {} as Record<string, FieldError>,\n        );\n\n        return toNestErrors(errors, options);\n      }),\n      Effect.tap(() =>\n        Effect.sync(\n          () =>\n            options.shouldUseNativeValidation &&\n            validateFieldsNatively({}, options),\n        ),\n      ),\n      Effect.match({\n        onFailure: (errors) => ({ errors, values: {} }),\n        onSuccess: (result) => ({ errors: {}, values: result }),\n      }),\n      Effect.runPromise,\n    );\n  };\n"],"names":["schema","config","errors","onExcessProperty","values","_","options","decodeUnknown","pipe","Effect","catchAll","parseIssue","flip","ArrayFormatter","formatIssue","mapError","issues","validateAllFieldCriteria","shouldUseNativeValidation","criteriaMode","reduce","acc","error","key","path","join","message","type","_tag","types","messages","String","appendErrors","concat","toNestErrors","tap","sync","validateFieldsNatively","match","onFailure","onSuccess","result","runPromise"],"mappings":"+IAQE,SAACA,EAAQC,GACT,YADSA,IAAAA,IAAAA,EAAS,CAAEC,OAAQ,MAAOC,iBAAkB,WACrD,SAACC,EAAQC,EAAGC,GACV,OAAOC,EAAaA,cAClBP,EACAC,EAFKM,CAGLH,GAAQI,KACRC,EAAMA,OAACC,SAAS,SAACC,UACfF,EAAAA,OAAOG,KAAKC,EAAcA,eAACC,YAAYH,GAAY,GAErDF,EAAMA,OAACM,SAAS,SAACC,GACf,IAAMC,GACHX,EAAQY,2BAAsD,QAAzBZ,EAAQa,aAE1CjB,EAASc,EAAOI,OACpB,SAACC,EAAKC,GACJ,IAAMC,EAAMD,EAAME,KAAKC,KAAK,KAM5B,GAJKJ,EAAIE,KACPF,EAAIE,GAAO,CAAEG,QAASJ,EAAMI,QAASC,KAAML,EAAMM,OAG/CX,EAA0B,CAC5B,IAAMY,EAAQR,EAAIE,GAAKM,MACjBC,EAAWD,GAASA,EAAME,OAAOT,EAAMM,OAE7CP,EAAIE,GAAOS,EAAAA,aACTT,EACAN,EACAI,EACAC,EAAMM,KACNE,EACK,GAAgBG,OAAOH,EAAsBR,EAAMI,SACpDJ,EAAMI,QAEd,CAEA,OAAOL,CACT,EACA,CAAA,GAGF,OAAOa,EAAYA,aAAChC,EAAQI,EAC9B,GACAG,SAAO0B,IAAI,WACT,OAAA1B,EAAMA,OAAC2B,KACL,WACE,OAAA9B,EAAQY,2BACRmB,EAAAA,uBAAuB,CAAE,EAAE/B,EAAQ,EACtC,GAEHG,SAAO6B,MAAM,CACXC,UAAW,SAACrC,GAAY,MAAA,CAAEA,OAAAA,EAAQE,OAAQ,GAAI,EAC9CoC,UAAW,SAACC,GAAY,MAAA,CAAEvC,OAAQ,CAAA,EAAIE,OAAQqC,EAAQ,IAExDhC,EAAAA,OAAOiC,WAEX,CAAC"}